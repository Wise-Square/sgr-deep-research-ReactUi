import React, { useState, useEffect, useRef } from 'react';
import MessageBubble from './MessageBubble';


type ChatItem = {
  id: number;
  title: string;
  timestamp: string;
  preview: string;
  messages: Array<{
    id: number, 
    type: 'question' | 'answer', 
    content: string, 
    timestamp: string
  }>;
};

type ChatProps = {
  currentChat: ChatItem | undefined;
  onSendMessage: (message: string) => void;
  setChatHistory: React.Dispatch<React.SetStateAction<ChatItem[]>>;
  t: (key: string) => string;
  sidebarVisible: boolean;
};


const Chat: React.FC<ChatProps> = ({ currentChat, onSendMessage, setChatHistory, t, sidebarVisible }) => {
    const [inputMessage, setInputMessage] = useState('');
    const [currentAgentId, setCurrentAgentId] = useState<string | null>(null);
    const lastBotMessageIdRef = useRef<number | null>(null);

    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º agent ID –ø—Ä–∏ —Å–º–µ–Ω–µ —á–∞—Ç–∞
    useEffect(() => {
        setCurrentAgentId(null);
        lastBotMessageIdRef.current = null;
        console.log('üîÑ Chat changed, reset agent state');
    }, [currentChat?.id]);
    

    const sendMessage = async () => {
        if (!inputMessage.trim() || !currentChat) return;
        
        const messageToSend = inputMessage; // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ –æ—á–∏—Å—Ç–∫–∏
        
        try {
            // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            const userMessage = {
                id: Date.now(),
                type: 'question' as const,
                content: messageToSend,
                timestamp: new Date().toLocaleTimeString()
            };
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —á–∞—Ç–∞
            setChatHistory(prev => prev.map(chat => 
                chat.id === currentChat.id 
                    ? { ...chat, messages: [...chat.messages, userMessage] }
                    : chat
            ));
            
            setInputMessage(''); // –û—á–∏—â–∞–µ–º –ø–æ–ª–µ –≤–≤–æ–¥–∞
            
            
            // –í—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ü–ï–†–ï–î getMessage
            await onSendMessage(messageToSend);
            
            const botMessageId = Date.now() + 1; // –°–æ–∑–¥–∞–µ–º ID –¥–ª—è –æ—Ç–≤–µ—Ç–∞ –±–æ—Ç–∞
            lastBotMessageIdRef.current = botMessageId; // –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –≤ ref
            console.log('üÜî Created bot message ID:', botMessageId);
            await getMessage(botMessageId, messageToSend);
            
        } catch (error) {
            console.error('Error sending message:', error);
        }
    };

    const getMessage = async (botMessageId: number, userMessage: string) => {
        const botMessage = {
            id: botMessageId,
            type: 'answer' as const,
            content: '',
            timestamp: new Date().toLocaleTimeString()
        }

        setChatHistory(prev => {
            // –ù–∞—Ö–æ–¥–∏–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π —á–∞—Ç –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
            const currentChatInState = prev.find(chat => chat.id === currentChat?.id);
            if (!currentChatInState) {
                console.error('Current chat not found in state');
                return prev;
            }
            
            console.log(`ü§ñ Adding bot message to chat with ${currentChatInState.messages.length} existing messages`);
            
            return prev.map(chat => 
                chat.id === currentChat?.id 
                    ? { ...chat, messages: [...chat.messages, botMessage] }
                    : chat
            );
        });

        const modelToUse = currentAgentId || 'sgr_agent';
        console.log('üöÄ Sending request with model:', modelToUse);
        
        const request = await fetch('/api/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model: modelToUse,
                messages: [{ role: 'user', content: userMessage }],
                stream: true,
                max_tokens: 1500,
                temperature: 0.4
            })
        });
        if (!request.ok) {
            throw new Error(`HTTP error! status: ${request.status}`);
        }
       console.log('üöÄ Request sent:', request);
        const reader = request.body?.getReader();
        const decoder = new TextDecoder();
        let fullResponse = '';

        if (reader) {
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') break;
                        
                        try {
                            const parsed = JSON.parse(data);
                            
                            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º currentAgentId –∏–∑ –æ—Ç–≤–µ—Ç–∞ —Å–µ—Ä–≤–µ—Ä–∞
                            if (parsed.model && parsed.model.startsWith('sgr_agent_')) {
                                console.log('üÜî Agent ID received:', parsed.model);
                                setCurrentAgentId(parsed.model);
                            }
                            
                            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±—ã—á–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
                            if (parsed.choices?.[0]?.delta?.content) {
                                const deltaContent = parsed.choices[0].delta.content;
                                
                                // –§–∏–ª—å—Ç—Ä—É–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —á–∏—Ç–∞–µ–º—ã–π —Ç–µ–∫—Å—Ç
                                if (!deltaContent.includes('{') && 
                                    !deltaContent.includes('tool_name_discriminator') &&
                                    !deltaContent.includes('"tool_name_discriminator"') &&
                                    deltaContent.trim().length > 0) {
                                    
                                    fullResponse += deltaContent;
                                    console.log(`üìù Updated content: ${fullResponse.length} chars`);
                                    
                                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–º —Å–æ–¥–µ—Ä–∂–∏–º—ã–º
                                    setChatHistory(prev => {
                                        const currentChatInState = prev.find(chat => chat.id === currentChat?.id);
                                        if (!currentChatInState) {
                                            console.error('Chat not found when updating content');
                                            return prev;
                                        }
                                        
                                        // –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–∏–ø–∞ 'answer' (–±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ —á–µ–º –ø–æ ID)
                                        const answerMessages = currentChatInState.messages.filter(msg => msg.type === 'answer');
                                        const targetMessage = answerMessages[answerMessages.length - 1];
                                        
                                        if (!targetMessage) {
                                            console.error('No answer message found. Available messages:', currentChatInState.messages.map(m => ({ id: m.id, type: m.type })));
                                            return prev;
                                        }
                                        
                                        console.log('üìù Updating last answer message', targetMessage.id, 'with', fullResponse.length, 'chars');
                                        
                                        return prev.map(chat => 
                                            chat.id === currentChat?.id 
                                                ? {
                                                    ...chat, 
                                                    messages: chat.messages.map(msg => 
                                                        msg.id === targetMessage.id 
                                                            ? { ...msg, content: fullResponse }
                                                            : msg
                                                    )
                                                }
                                                : chat
                                        );
                                    });
                                }
                            }
                            
                            // –ù–û–í–û–ï: –û–±—Ä–∞–±–æ—Ç–∫–∞ tool_calls
                            if (parsed.choices?.[0]?.delta?.tool_calls) {
                                const toolCall = parsed.choices[0].delta.tool_calls[0];
                                console.log('üîß Tool call received:', toolCall?.function?.name);
                                
                                if (toolCall?.function?.name === 'createreporttool') {
                                    // –°–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –æ—Ç—á–µ—Ç–∞
                                    try {
                                        const args = JSON.parse(toolCall.function.arguments);
                                        const reportContent = args.content || '';
                                        
                                        if (reportContent && reportContent.trim()) {
                                            console.log('üìã Creating separate report message:', reportContent.length, 'chars');
                                            console.log('üìã Report content preview:', reportContent.substring(0, 200) + '...');
                                            
                                            const reportMessage = {
                                                id: Date.now() + 3,
                                                type: 'answer' as const,
                                                content: reportContent,
                                                timestamp: new Date().toLocaleTimeString()
                                            };
                                            
                                            setChatHistory(prev => {
                                                const currentChatInState = prev.find(chat => chat.id === currentChat?.id);
                                                if (!currentChatInState) {
                                                    console.error('Chat not found when creating report message');
                                                    return prev;
                                                }
                                                
                                                console.log('üìã Adding report message to chat with', currentChatInState.messages.length, 'existing messages');
                                                
                                                return prev.map(chat => 
                                                    chat.id === currentChat?.id 
                                                        ? { ...chat, messages: [...chat.messages, reportMessage] }
                                                        : chat
                                                );
                                            });
                                        }
                                    } catch (error) {
                                        console.error('‚ùå Error parsing report content:', error);
                                    }
                                } else if (toolCall?.function?.name === 'agentcompletiontool') {
                                    // –õ–æ–≥–∏—Ä—É–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏
                                    try {
                                        const args = JSON.parse(toolCall.function.arguments);
                                        const completionReasoning = args.reasoning || '';
                                        console.log('‚úÖ Task completion received (streaming):', completionReasoning);
                                        console.log('‚úÖ NOT overwriting report content - keeping separate messages');
                                    } catch (error) {
                                        console.error('‚ùå Error parsing completion data:', error);
                                    }
                                } else {
                                    // –î–ª—è –¥—Ä—É–≥–∏—Ö tool calls –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º
                                    console.log('üîß Other tool call:', toolCall?.function?.name, '- content will be added to current message');
                                }
                            }
                            
                            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç (–∫–æ–≥–¥–∞ finish_reason = "stop")
                            if (parsed.choices?.[0]?.message?.content) {
                                const finalContent = parsed.choices[0].message.content;
                                
                                // –ï—Å–ª–∏ —É –Ω–∞—Å –µ—â–µ –Ω–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
                                if (!fullResponse.trim()) {
                                    fullResponse = finalContent;
                                    console.log(`üèÅ Using final content: ${fullResponse.length} chars`);
                                    setChatHistory(prev => {
                                        const currentChatInState = prev.find(chat => chat.id === currentChat?.id);
                                        if (!currentChatInState) {
                                            console.error('Chat not found when setting final content');
                                            return prev;
                                        }
                                        
                                        // –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–∏–ø–∞ 'answer' (–±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ —á–µ–º –ø–æ ID)
                                        const answerMessages = currentChatInState.messages.filter(msg => msg.type === 'answer');
                                        const targetMessage = answerMessages[answerMessages.length - 1];
                                        
                                        if (!targetMessage) {
                                            console.error('No answer message found for final content. Available messages:', currentChatInState.messages.map(m => ({ id: m.id, type: m.type })));
                                            return prev;
                                        }
                                        
                                        console.log('üèÅ Setting final content for last answer message', targetMessage.id, 'with', fullResponse.length, 'chars');
                                        
                                        return prev.map(chat => 
                                            chat.id === currentChat?.id 
                                                ? {
                                                    ...chat, 
                                                    messages: chat.messages.map(msg => 
                                                        msg.id === targetMessage.id 
                                                            ? { ...msg, content: fullResponse }
                                                            : msg
                                                    )
                                                }
                                                : chat
                                        );
                                    });
                                }
                            }
                            
                            // –ù–û–í–û–ï: –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏–∑ tool_calls (–≤ delta)
                            if (parsed.choices?.[0]?.delta?.tool_calls) {
                                const toolCalls = parsed.choices[0].delta.tool_calls;
                                
                                for (const toolCall of toolCalls) {
                                    if (toolCall.function?.name === 'agentcompletiontool') {
                                        // –¢–æ–ª—å–∫–æ –ª–æ–≥–∏—Ä—É–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ, –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç
                                        try {
                                            const args = JSON.parse(toolCall.function.arguments);
                                            const completionReasoning = args.reasoning || '';
                                            console.log('‚úÖ Task completion received from delta:', completionReasoning);
                                        console.log('‚úÖ NOT overwriting report content - keeping separate messages');
                                        } catch (error) {
                                            console.error('‚ùå Error parsing completion data:', error);
                                        }
                                    }
                                }
                            }
                            
                            // –ù–û–í–û–ï: –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏–∑ message.tool_calls (—Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç)
                            if (parsed.choices?.[0]?.message?.tool_calls) {
                                const toolCalls = parsed.choices[0].message.tool_calls;
                                console.log('üîß Final message tool calls received:', toolCalls.length);
                                
                                for (const toolCall of toolCalls) {
                                    if (toolCall.function?.name === 'agentcompletiontool') {
                                        // –¢–æ–ª—å–∫–æ –ª–æ–≥–∏—Ä—É–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ, –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç
                                        try {
                                            const args = JSON.parse(toolCall.function.arguments);
                                            const completionReasoning = args.reasoning || '';
                                            console.log('‚úÖ Task completion received from message:', completionReasoning);
                                            console.log('‚úÖ NOT overwriting report content - keeping separate messages');
                                        } catch (error) {
                                            console.error('‚ùå Error parsing completion data:', error);
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
                        }
                    }
                }
            }
        }
        
        console.log(`üéØ Final result: ${fullResponse.length} chars`);
        return fullResponse;
    };

      const handleKeyPress = (e: React.KeyboardEvent) => {
        if (e.key === 'Enter') {
            sendMessage();
        }
    };


    return (
        <>
            <div className={`chat-container ${!sidebarVisible ? 'expanded' : ''}`}>
                <div className="chat-header">
                    <h2 className="chat-title">{currentChat ? currentChat.title : t('select_chat')}</h2>
                </div>
                
                <div className="chat-messages">
                    {!currentChat ? (
                        <div className="empty-chat">
                            <svg width="64" height="64" viewBox="0 0 24 24" fill="currentColor" className="empty-icon">
                                <path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
                            </svg>
                            <p className="empty-text">{t('select_chat_or_create')}</p>
                        </div>
                    ) : currentChat.messages.length === 0 ? (
                        <div className="empty-chat">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor" className="empty-icon">
                                <path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
                            </svg>
                            <p className="empty-text">{t('start_new_conversation')}</p>
                            <p className="empty-subtext">{t('enter_message_below')}</p>
                        </div>
                    ) : (
                        <>
                            {/* –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ currentChat */}
                            {currentChat.messages.map((message) => (
                                <MessageBubble
                                    key={message.id}
                                    message={message.content}
                                    timestamp={message.timestamp}
                                    type={message.type === 'question' ? 'user' : 'assistant'}
                                />
                            ))}
                            
                        </>
                    )}
                </div>
            </div>
            
            <div className={`chat-input-section ${!sidebarVisible ? 'expanded' : ''}`}>
                <div className="input-group modern-chat-input">
                    <input
                        type="text"
                        className="form-control chat-input"
                        placeholder={
                            currentChat 
                                ? t('enter_message') 
                                : t('select_chat_or_create')
                        }
                        aria-label="Chat input"
                        value={inputMessage}
                        onChange={(e) => setInputMessage(e.target.value)}
                        onKeyPress={handleKeyPress}
                    />
                    <button
                        className="btn btn-primary send-button"
                        type="button"
                        onClick={sendMessage}
                    >
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                        </svg>
                    </button>
                </div>
            </div>
        </>
    );
};

export default Chat;